#
# GitHub Actions Workflow to build NGINX packages for multiple Debian versions.
# This approach uses dynamic linking against the system's libraries for better
# integration, smaller package size, and easier security patch management via `apt`.
#

name: Build and Release NGINX with ACME Module Package

on:
  workflow_dispatch:
    inputs:
      nginx_version:
        description: 'Optional: Specify an NGINX version to build (e.g., 1.28.0)'
        required: false
        default: ''
  schedule:
    - cron: '30 5 * * *'
  push:
    branches:
      - master

permissions:
  contents: write

jobs:
  # This job checks if a new version of NGINX is available or if a manual
  # build has been triggered. It acts as a gatekeeper for the build jobs.
  check-for-new-version:
    name: Check for New NGINX Stable Version
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_versions.outputs.should_build }}
      version: ${{ steps.check_versions.outputs.version }}
    steps:
      - name: Determine version and if build is needed
        id: check_versions
        run: |
          MANUAL_VERSION="${{ github.event.inputs.nginx_version }}"

          if [ -n "$MANUAL_VERSION" ]; then
            echo "Manual version specified: $MANUAL_VERSION. Forcing build."
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            echo "version=$MANUAL_VERSION" >> "$GITHUB_OUTPUT"
          else
            echo "No manual version specified. Detecting latest stable version..."
            LATEST_STABLE=$(curl -s https://nginx.org/download/ | \
              grep -o 'nginx-[0-9.]\+\.tar\.gz' | \
              sed -e 's/nginx-//' -e 's/\.tar\.gz//' | \
              awk -F. '$2 % 2 == 0' | \
              sort -V | \
              tail -n 1)

            if [ -z "$LATEST_STABLE" ]; then
              echo "ERROR: Failed to parse latest stable NGINX version."
              exit 1
            fi
            echo "Latest stable NGINX version is: $LATEST_STABLE"

            LATEST_RELEASE_TAG=$(curl -sf -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" | \
              jq -r .tag_name || true)

            if [ -z "$LATEST_RELEASE_TAG" ]; then
              echo "No previous release found. Triggering initial build."
              echo "should_build=true" >> "$GITHUB_OUTPUT"
            else
              LAST_RELEASED_VERSION=$(echo "$LATEST_RELEASE_TAG" | sed 's/^nginx-//')
              echo "Last released version is: $LAST_RELEASED_VERSION"
              if [ "$LATEST_STABLE" != "$LAST_RELEASED_VERSION" ]; then
                echo "New version detected ($LATEST_STABLE). Proceeding with build."
                echo "should_build=true" >> "$GITHUB_OUTPUT"
              else
                echo "Version $LATEST_STABLE is already the latest. Build skipped."
                echo "should_build=false" >> "$GITHUB_OUTPUT"
              fi
            fi
            echo "version=$LATEST_STABLE" >> "$GITHUB_OUTPUT"
          fi

  # This job builds the NGINX binary and the ACME module for different
  # Debian versions in parallel using a matrix strategy.
  build-debian:
    name: Build for ${{ matrix.os_name }}
    needs: check-for-new-version
    if: needs.check-for-new-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest

    # Define the matrix to run this job for each specified Debian version.
    strategy:
      matrix:
        include:
          - os_name: Debian 11 (Bullseye)
            os_tag: '11'
          - os_name: Debian 12 (Bookworm)
            os_tag: '12'

    # Use the matrix variable to select the correct Docker container.
    container: debian:${{ matrix.os_tag }}

    steps:
      - name: Install Build Dependencies
        run: |
          apt-get update
          # Install libssl-dev for dynamic linking against the system's OpenSSL.
          apt-get install -y --no-install-recommends \
            build-essential libclang-dev pkg-config libpcre2-dev zlib1g-dev libssl-dev \
            libxml2-dev libxslt1-dev libgd-dev libgeoip-dev libperl-dev \
            wget git curl ca-certificates jq

      - name: Install Rust Toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Download and Build (Dynamically Linked)
        env:
          NGINX_VERSION: ${{ needs.check-for-new-version.outputs.version }}
        run: |
          wget -q http://nginx.org/download/nginx-$NGINX_VERSION.tar.gz
          tar -zxf nginx-$NGINX_VERSION.tar.gz
          git clone --depth 1 https://github.com/nginx/nginx-acme.git
          cd nginx-$NGINX_VERSION

          BUILD_PATH=$(pwd)
          CC_OPT_VALUE="-g -O2 -ffile-prefix-map=$BUILD_PATH=. -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC"

          # Configure NGINX for a portable layout, linking against system libraries.
          # The ACME module is built as a dynamic module (`.so` file).
          ./configure \
            --with-cc-opt="$CC_OPT_VALUE" \
            --with-ld-opt='-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -fPIC' \
            --prefix=.. \
            --conf-path=nginx.conf \
            --http-log-path=logs/access.log \
            --error-log-path=logs/error.log \
            --lock-path=run/nginx.lock \
            --pid-path=run/nginx.pid \
            --modules-path=modules \
            --http-client-body-temp-path=temp/body \
            --http-fastcgi-temp-path=temp/fastcgi \
            --http-proxy-temp-path=temp/proxy \
            --http-scgi-temp-path=temp/scgi \
            --http-uwsgi-temp-path=temp/uwsgi \
            --with-compat \
            --with-debug \
            --with-pcre-jit \
            --with-http_ssl_module \
            --with-http_stub_status_module \
            --with-http_realip_module \
            --with-http_auth_request_module \
            --with-http_v2_module \
            --add-dynamic-module=../nginx-acme/

          make

      - name: Package Artifacts
        env:
          NGINX_VERSION: ${{ needs.check-for-new-version.outputs.version }}
          OS_TAG: ${{ matrix.os_tag }}
        run: |
          SOURCE_DIR="nginx-$NGINX_VERSION"
          MODULE_PATH="$SOURCE_DIR/objs/ngx_http_acme_module.so"
          NGINX_BINARY_PATH="$SOURCE_DIR/objs/nginx"

          if [ ! -f "$MODULE_PATH" ] || [ ! -f "$NGINX_BINARY_PATH" ]; then
            echo "::error::Build failed! Required files were not created."
            exit 1
          fi

          PACKAGE_BASE_DIR="nginx_acme"
          mkdir -p "$PACKAGE_BASE_DIR/sbin"
          mkdir -p "$PACKAGE_BASE_DIR/modules"
          mkdir -p "$PACKAGE_BASE_DIR/vhost"
          mkdir -p "$PACKAGE_BASE_DIR/acme"
          mkdir -p "$PACKAGE_BASE_DIR/logs"
          mkdir -p "$PACKAGE_BASE_DIR/run"
          mkdir -p "$PACKAGE_BASE_DIR/temp/body"
          mkdir -p "$PACKAGE_BASE_DIR/temp/proxy"
          mkdir -p "$PACKAGE_BASE_DIR/temp/fastcgi"
          mkdir -p "$PACKAGE_BASE_DIR/temp/scgi"
          mkdir -p "$PACKAGE_BASE_DIR/temp/uwsgi"

          cp "$NGINX_BINARY_PATH" "$PACKAGE_BASE_DIR/sbin/nginx"
          cp "$MODULE_PATH" "$PACKAGE_BASE_DIR/modules/ngx_http_acme_module.so"
          cp "$SOURCE_DIR/conf/mime.types" "$PACKAGE_BASE_DIR/"
          cp "$SOURCE_DIR/conf/nginx.conf" "$PACKAGE_BASE_DIR/"

          # Add the `load_module` directive back to the config template.
          CONFIG_FILE="$PACKAGE_BASE_DIR/nginx.conf"
          sed -i '1s|^|# To enable the NGINX ACME module, uncomment the following line:\n# load_module modules/ngx_http_acme_module.so;\n\n|' "$CONFIG_FILE"
          sed -i 's|#pid        logs/nginx.pid;|pid        run/nginx.pid;|' "$CONFIG_FILE"
          sed -i '/^\s*include\s*mime.types;\s*$/a \
              client_body_temp_path temp/body;\n    proxy_temp_path temp/proxy;\n    fastcgi_temp_path temp/fastcgi;\n    scgi_temp_path temp/scgi;\n    uwsgi_temp_path temp/uwsgi;' "$CONFIG_FILE"
          sed -i '/^\s*include\s*mime.types;\s*$/i # Load virtual host configs.\n    include vhost/*.conf;' "$CONFIG_FILE"

          cat <<'EOF' > "$PACKAGE_BASE_DIR/vhost/default.conf.example"
          # This is an example virtual host configuration file.
          # To use it, rename this file to 'your_site.conf' and fill in your details.

          # --- HTTP Server: Handles ACME challenge and redirects to HTTPS ---
          server {
              listen 80;
              listen [::]:80;

              # Replace with your domain(s)
              server_name your_domain.com www.your_domain.com;

              # This location is required by the ACME module to solve the HTTP-01 challenge.
              # Create this directory: `mkdir -p acme/challenge-root`
              location /.well-known/acme-challenge/ {
                  root acme/challenge-root;
              }

              # For all other requests, redirect HTTP traffic to HTTPS.
              location / {
                  return 301 https://$host$request_uri;
              }
          }

          # --- HTTPS Server Block (Your main configuration) ---
          #
          # IMPORTANT: Uncomment this entire block only AFTER the first certificate
          # has been successfully obtained. Otherwise, NGINX will fail to start
          # because the certificate files do not exist yet.
          #
          # server {
          #     listen 443 ssl http2;
          #     listen [::]:443 ssl http2;
          #
          #     server_name your_domain.com www.your_domain.com;
          #
          #     # --- ACME Module Configuration ---
          #
          #     # Enable automatic certificate management for this server block.
          #     acme on;
          #
          #     # Define the path where certificates and account keys will be stored.
          #     # This path is relative to the directory where you run nginx (the package root).
          #     # The module will create a `storage` subdirectory inside `acme/`.
          #     acme_storage_path acme;
          #
          #     # Tell the module which certificate to manage.
          #     acme_certificate your_domain.com {
          #         # Set your Let's Encrypt account email (required).
          #         account mail@your_domain.com;
          #         # Add any alternative domains for the same certificate (optional).
          #         # domains www.your_domain.com;
          #     }
          #
          #     # --- SSL Configuration ---
          #
          #     # Point NGINX to the certificate and key files managed by the ACME module.
          #     # The paths are relative to the 'acme_storage_path' defined above.
          #     ssl_certificate acme/storage/your_domain.com/fullchain.pem;
          #     ssl_certificate_key acme/storage/your_domain.com/key.pem;
          #
          #     # Recommended: Add modern SSL/TLS parameters for security.
          #     ssl_protocols TLSv1.2 TLSv1.3;
          #     ssl_ciphers HIGH:!aNULL:!MD5;
          #
          #     # --- Website Configuration ---
          #
          #     # Your website's root directory and other configurations go here.
          #     location / {
          #         root /path/to/your/website;
          #         index index.html;
          #     }
          # }
          EOF

          cat <<'EOF' > "$PACKAGE_BASE_DIR/README.txt"
          # NGINX with ACME Module Package

          This package is fully portable. All paths in the configuration have been made relative.

          ## Quick Start Guide

          **Step 1: Unpack & Enter Directory**
          ```bash
          tar -xzf <archive-name>.tar.gz
          cd nginx-acme
          ```

          **Step 2: Enable the ACME Module**
          Open `nginx.conf` and uncomment the `load_module` line at the top.

          **Step 3: Configure Your Website**
          1. Rename `vhost/default.conf.example` to `vhost/your_site.conf`.
          2. Edit the new file with your domain and settings.
          3. Create the ACME challenge directory if needed.

          **Step 4: Start NGINX**
          (Commands remain the same, to be run from inside the `nginx-acme` directory)
          ```bash
          # Test configuration
          ./sbin/nginx -p $(pwd) -c nginx.conf -t

          # Start NGINX
          ./sbin/nginx -p $(pwd) -c nginx.conf
          ```

          **Step 5: Manage NGINX**
          - **Reload:** `./sbin/nginx -p $(pwd) -s reload`
          - **Stop:** `./sbin/nginx -p $(pwd) -s stop`
          EOF

          # Use the matrix variable to create a uniquely named archive.
          ARTIFACT_NAME="nginx-${NGINX_VERSION}-acme-debian${OS_TAG}.tar.gz"
          tar -czf "$ARTIFACT_NAME" "$PACKAGE_BASE_DIR"

          ARTIFACT_DIR=artifact
          mkdir -p "$ARTIFACT_DIR"
          mv "$ARTIFACT_NAME" "$ARTIFACT_DIR/"
          sha256sum "$ARTIFACT_DIR/$ARTIFACT_NAME" > "$ARTIFACT_DIR/$ARTIFACT_NAME.sha256"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          # Use a unique name for the artifact to prevent conflicts between matrix jobs.
          name: nginx-package-debian${{ matrix.os_tag }}
          path: artifact/

  # This job runs only after all matrix build jobs have succeeded. It collects
  # all the generated packages and publishes them to a single GitHub Release.
  create-release:
    name: Create GitHub Release
    needs: [check-for-new-version, build-debian]
    if: needs.check-for-new-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts from build jobs
        uses: actions/download-artifact@v4
        with:
          path: ./dist
          # Use a pattern to download all artifacts produced by the matrix.
          pattern: nginx-package-*
          merge-multiple: true

      - name: List downloaded files for debugging
        run: ls -R ./dist

      - name: Prepare release content and assets
        id: prep
        run: |
          mkdir -p release-assets
          # Move all downloaded packages to the release assets directory.
          find ./dist -name "*.tar.gz" -exec mv {} ./release-assets/ \;

          echo "### SHA256 Checksums" > release-body.md
          echo '```' >> release-body.md
          # Combine all checksum files into the release body.
          find ./dist -name "*.sha256" -exec cat {} + >> release-body.md
          echo '```' >> release-body.md
          {
            echo "body<<EOF"
            cat release-body.md
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create Release and Upload All Assets
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: nginx-${{ needs.check-for-new-version.outputs.version }}
          name: NGINX ${{ needs.check-for-new-version.outputs.version }} with ACME Module Packages
          body: ${{ steps.prep.outputs.body }}
          # Use a glob pattern to upload all packaged archives.
          files: ./release-assets/*.tar.gz
